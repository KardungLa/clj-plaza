<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en-US" xml:lang="en-US" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
    <title>working with RDF</title>
    <meta content="Antonio Garrrote Hern&aacute;ndez" name="author" />
   <link href="/clj-plaza/css/screen.css" rel="stylesheet" type="text/css" />
   <link href="/clj-plaza/css/syntax.css" rel="stylesheet" type="text/css" />
 </head>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-15922180-1");
pageTracker._trackPageview();
} catch(err) {}</script>
  <body>
    <div id="site">
      <div id="sidebar">
        <div id="title">
          <p><a href="/clj-plaza/"><img src="/clj-plaza/images/logo.png" alt="" /></a></p>
          <p><a href="/clj-plaza/">clj-plaza</a></p>
        </div>
        <p>

          A Clojure library to work with semantic meta-data.

        <div id="github">
          Fork me at <br/>
          <a href="http://github.com/antoniogarrote/clj-plaza">
          <img src="http://github.com/images/modules/header/logov3.png"></img>
          </a>
        </div>
     </div>

        <div id="post"
  <h1> working with RDF </h1>
  <p class="subtitle">
 </p>
<div id="content">
  <p>
<ul>
        <li><a href="#describing_triples">Describing triples</a></li>
        <li><a href="#working_triples">Literals and typed literals</a></li>
        <li><a href="#models">Models</a></li>
        <li><a href="#io">Input/Output</a></li>
        <li><a href="#rdfa">Parsing RDFa documents</a></li>
        <li><a href="#processing">Triple sets processing</a></li>
        <li><a href="#predicates">Using predicates</a></li>
        <li><a href="#patterns_triples">Patterns, queries, triple sets and<br />
        models</a></li>
        <li><a href="#pattern_building">Building patterns</a></li>
        <li><a href="#defquery">Defining queries</a></li>
        <li><a href="#filters">Adding filters</a></li>
        <li><a href="#making_queries">Using queries</a></li>
</ul>
</p>
<p>The foundation of the semantic web technologies stack as conceived by the W3C is the <a
href="http://www.w3.org/RDF/">Resource Description Framework(<span class="caps">RDF</span>)</a>.</p>
<p><strong>clj-plaza</strong> tries to make the use of <span class="caps">RDF</span> in Clojure easy and idiomatic.</p>
<p><span class="caps">RDF</span> is different things at the same time</p>

	<ul>
		<li>a data model based in a graph of linked URIs</li>
		<li>a vocabulary for data description</li>
		<li>a formal system defining the validity of the described data and inference rules</li>
	</ul><p><span class="caps">RDF</span> data model is based on two main building blocks: URIs and <span class="caps">RDF</span> literals. URIs can be used to<br />
identify any resource to be described. Resources can have properties, also identified by URIs,<br />
linking resources or associating values to a resource. The primitive values of the properties are<br />
described using <span class="caps">RDF</span> literals.</p>
<p>The graph of relations among resources and literal values can be serialized as a set of triples with<br />
subject, predicate and object, where the <span class="caps">URI</span> in a triple object can be the subject of a different triple.</p>
<p>For instance, the <span class="caps">RDF</span> graph:<br />
<div id="img_wrapper"><br />
<img
src="http://www.w3.org/TR/2004/REC-rdf-primer-20040210/fig2dec16.png"></img></p>
</div>
<p>can be serialized as:</p>
<div class="highlight"><pre><code class="xml"><span class="nt">&lt;http:</span><span class="err">//www.example.org/index.html</span><span class="nt">&gt;</span>
      <span class="nt">&lt;http:</span><span class="err">//purl.org/dc/elements/1.1/creator</span><span class="nt">&gt;</span> <span class="nt">&lt;http:</span><span class="err">//www.example.org/staffid/85740</span><span class="nt">&gt;</span> .
</code></pre>
</div><h2 id="describing_triples">Describing sets of triples</h2>
<p>In <strong>clj-plaza</strong>, you describe a triple as a vector with three components, and a <span class="caps">RDF</span> graph as a vector<br />
with triples. The previous graph can be encoded with <strong>clj-plaza</strong> using the following code:</p>
<div class="highlight"><pre><code class="clojure"><span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;plaza</span><span class="o">.</span><span class="nv">rdf</span><span class="o">.</span><span class="nv">core</span><span class="p">)</span>
<span class="p">(</span><span class="nf">make-triples</span> <span class="p">[[</span><span class="s">&quot;http://www.example.org/index.html&quot;</span>
                  <span class="s">&quot;http://purl.org/dc/elements/1.1/creator&quot;</span>
                  <span class="s">&quot;http://www.example.org/staffid/85740&quot;</span><span class="p">]])</span>
</code></pre>
</div><p>This way of describing data is quite verbose so it is a good idea to define the namespaces we are<br />
going to use. This way the description of data can be less tedious. <strong>clj-plaza</strong> offers some<br />
functions for dealing with namespaces:</p>
<div class="highlight"><pre><code class="clojure"><span class="p">(</span><span class="nf">register-rdf-ns</span> <span class="nv">:ex</span> <span class="s">&quot;http://www.example.org/index.html&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">register-rdf-ns</span> <span class="nv">:dc</span> <span class="s">&quot;http://purl.org/dc/elements/1.1/&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">make-triples</span> <span class="p">[[[</span><span class="nv">:ex</span> <span class="nv">:index</span><span class="o">.</span><span class="nv">html</span><span class="p">]</span> <span class="p">[</span><span class="nv">:dc</span> <span class="nv">:creator</span><span class="p">]</span> <span class="p">[</span><span class="nv">:ex</span> <span class="s">&quot;staffid/85740&quot;</span><span class="p">]]])</span>
</code></pre>
</div><p>We can also set up a default namespace so all the unqualified strings will be resolved using this<br />
default namespace:</p>
<div class="highlight"><pre><code class="clojure"><span class="p">(</span><span class="nf">alter-root-rdf-ns</span> <span class="s">&quot;http://www.example.org/&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">make-triples</span> <span class="p">[[</span><span class="nv">:index</span><span class="o">.</span><span class="nv">html</span> <span class="p">[</span><span class="nv">:dc</span> <span class="nv">:creator</span><span class="p">]</span> <span class="s">&quot;staffid/85740&quot;</span><span class="p">]])</span>
</code></pre>
</div><p>This way of modifying the default namespace can cause problems in a multithreaded environment and it<br />
should be only used when setting the environment at the start of the application execution.</p>
<p><strong>clj-plaza</strong> includes a different mechanism for changing temporarily the default namespace in a per<br />
 thread basis using the <code>with-rdf-ns</code> macro:</p>
<div class="highlight"><pre><code class="clojure"><span class="p">(</span><span class="nf">with-rdf-ns</span> <span class="s">&quot;http://www.example.org/&quot;</span>
   <span class="p">(</span><span class="nf">make-triples</span> <span class="p">[[</span><span class="nv">:index</span><span class="o">.</span><span class="nv">html</span> <span class="p">[</span><span class="nv">:dc</span> <span class="nv">:creator</span><span class="p">]</span> <span class="s">&quot;staffid/85740&quot;</span><span class="p">]]))</span>
</code></pre>
</div><p>Sometimes you need to build a graph where there is a lot of different properties relating to the same<br />
resource. For instance, if you need to describe a graph like:</p>
<div id="img_wrapper">
<p><img src="/clj-plaza/images/diag1.png"></img></p>
</div>
<p>You can describe it using a collection of pairs of property &#8211; object, associated to the same subject:</p>
<div class="highlight"><pre><code class="clojure"><span class="p">(</span><span class="nf">make-triples</span> <span class="p">[[</span><span class="nv">:a</span> <span class="p">[</span><span class="nv">:p</span> <span class="nv">:b</span>
                      <span class="nv">:r</span> <span class="nv">:c</span>
                      <span class="nv">:s</span> <span class="nv">:d</span><span class="p">]]])</span>
</code></pre>
</div><h2 id="working_triples">Literals and typed literals</h2>
<p>When describing a graph, some properties will be relations between resources, identified by URIs,<br />
and some other properties will link resources to data describing that resource. These latest values<br />
are inserted into the <span class="caps">RDF</span> graph as <em>literal nodes</em>. Literal nodes can have an associated type as described in the<br />
<a href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#section-Datatypes"><span class="caps">RDF</span> specification</a>.</p>
<p>We can use the functions <code>rdf-literal</code> and <code>rdf-typed-literal</code> to add some<br />
values to a graph:</p>
<div class="highlight"><pre><code class="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">*book-uri*</span> <span class="s">&quot;http://www.amazon.com/Art-Metaobject-Protocol-Gregor-Kiczales/dp/0262610744&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">*book-title*</span> <span class="s">&quot;The Art of the Metaobject Protocol&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">*publication*</span> <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">c</span> <span class="p">(</span><span class="nf">java</span><span class="o">.</span><span class="nv">util</span><span class="o">.</span><span class="nv">Calendar/getInstance</span><span class="p">)]</span>
                            <span class="p">(</span><span class="o">.</span><span class="nv">set</span> <span class="nv">c</span> <span class="mi">1991</span> <span class="mi">12</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">c</span><span class="p">))</span>
<span class="p">(</span><span class="nf">make-triples</span>
  <span class="p">[[</span> <span class="nv">*book-uri*</span> <span class="p">[</span> <span class="p">[</span><span class="nv">:dc</span> <span class="nv">:title</span><span class="p">]</span> <span class="p">(</span><span class="nf">rdf-literal</span> <span class="nv">*book-title*</span><span class="p">)</span>
                  <span class="p">[</span><span class="nv">:dc</span> <span class="nv">:date</span><span class="p">]</span>  <span class="p">(</span><span class="nf">rdf-typed-literal</span> <span class="nv">*publication*</span>
                                                    <span class="nv">:datetime</span><span class="p">)</span> <span class="p">]]])</span>
</code></pre>
</div><p>To make this representation more compact, we can use the <code>l</code> and <code>d</code> shortcuts<br />
for the <code>rdf-literal</code> and <code>rdf-typed-literal</code> functions. It is also not<br />
necessary to pass as an argument the type of the data type, it will be inferred automatically.</p>
<p>With all this modifications, it is possible to specify the same graph as:</p>
<div class="highlight"><pre><code class="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">*book-uri*</span> <span class="s">&quot;http://www.amazon.com/Art-Metaobject-Protocol-Gregor-Kiczales/dp/0262610744&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">*book-title*</span> <span class="s">&quot;The Art of the Metaobject Protocol&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">*publication*</span> <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">c</span> <span class="p">(</span><span class="nf">java</span><span class="o">.</span><span class="nv">util</span><span class="o">.</span><span class="nv">Calendar/getInstance</span><span class="p">)]</span>
                            <span class="p">(</span><span class="o">.</span><span class="nv">set</span> <span class="nv">c</span> <span class="mi">1991</span> <span class="mi">12</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">c</span><span class="p">))</span>
<span class="p">(</span><span class="nf">make-triples</span>
  <span class="p">[[</span> <span class="nv">*book-uri*</span> <span class="p">[</span> <span class="p">[</span><span class="nv">:dc</span> <span class="nv">:title</span><span class="p">]</span> <span class="p">(</span><span class="nf">l</span> <span class="nv">*book-title*</span><span class="p">)</span>
                  <span class="p">[</span><span class="nv">:dc</span> <span class="nv">:date</span><span class="p">]</span>  <span class="p">(</span><span class="nf">d</span> <span class="nv">*publication*</span><span class="p">)</span> <span class="p">]]])</span>
</code></pre>
</div><p>Some other possibilities include passing a language for the strings in the literal values as well<br />
as a function for dealing directly with dates:</p>
<div class="highlight"><pre><code class="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">*book-uri*</span> <span class="s">&quot;http://www.amazon.com/Art-Metaobject-Protocol-Gregor-Kiczales/dp/0262610744&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">*book-title*</span> <span class="s">&quot;The Art of the Metaobject Protocol&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="nf">make-triples</span>
  <span class="p">[[</span> <span class="nv">*book-uri*</span> <span class="p">[</span> <span class="p">[</span><span class="nv">:dc</span> <span class="nv">:title</span><span class="p">]</span> <span class="p">(</span><span class="nf">l</span> <span class="nv">*book-title*</span> <span class="nv">:en</span><span class="p">)</span>
                  <span class="p">[</span><span class="nv">:dc</span> <span class="nv">:date</span><span class="p">]</span>  <span class="p">(</span><span class="nf">date</span> <span class="mi">1991</span> <span class="mi">12</span> <span class="mi">1</span><span class="p">)</span> <span class="p">]]])</span>
</code></pre>
</div><h2 id="models">Models</h2>
<p>Collections of triples can be stored into an intermediary shared memory zone denominated a model where some<br />
model operations can be applied. All<br />
model operations can be invoked safely by different threads.</p>
<p>There is a default model bound to the <code>*rdf-model*</code>. Every single model operation will<br />
manipulate by default this shared model.</p>
<p>New models can be created using the <code>defmodel</code> macro. You can also pass some forms as<br />
arguments to <code>defmodel</code>, model operations in these forms will be applied to the model<br />
being defined:</p>
<div class="highlight"><pre><code class="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">*ml*</span> <span class="p">(</span><span class="nf">defmodel</span>
             <span class="p">(</span><span class="nf">model-add-triples</span> <span class="p">(</span><span class="nf">make-triples</span> <span class="p">[[</span><span class="nv">:a</span> <span class="nv">:b</span> <span class="p">(</span><span class="nf">d</span> <span class="mi">2</span><span class="p">)]]))</span>
             <span class="p">(</span><span class="nf">model-add-triples</span> <span class="p">(</span><span class="nf">make-triples</span> <span class="p">[[</span><span class="nv">:e</span> <span class="nv">:f</span> <span class="p">(</span><span class="nf">l</span> <span class="s">&quot;test&quot;</span><span class="p">)]]))))</span>
</code></pre>
</div><p>Triples stored inside a model can always be recovered using the <code>model-to-triples</code><br />
function. These triples can be manipulated without affecting the model where the triples where extracted from.</p>
<div class="highlight"><pre><code class="clojure"><span class="p">(</span><span class="nb">= </span><span class="mi">2</span> <span class="p">(</span><span class="nb">count </span><span class="p">(</span><span class="nf">model-to-triples</span> <span class="nv">*ml*</span><span class="p">)))</span>
</code></pre>
</div><p>When several models are defined, the model where operations will be applied can be chosen using the<br />
<code>with-model</code> macro:</p>
<div class="highlight"><pre><code class="clojure"><span class="p">(</span><span class="nf">with-model</span> <span class="nv">*ml*</span>
             <span class="p">(</span><span class="nf">model-remove-triples</span> <span class="p">(</span><span class="nf">make-triples</span> <span class="p">[[</span><span class="nv">:a</span> <span class="nv">:b</span> <span class="p">(</span><span class="nf">d</span> <span class="mi">2</span><span class="p">)]])))</span>
</code></pre>
</div><p>Any model operation accepts, as a convenience, the representation of a set of<br />
triples instead of the triple-set:</p>
<div class="highlight"><pre><code class="clojure"><span class="p">(</span><span class="nf">with-model</span> <span class="nv">*ml*</span>
             <span class="p">(</span><span class="nf">model-remove-triples</span> <span class="p">[[</span><span class="nv">:e</span> <span class="nv">:f</span> <span class="p">(</span><span class="nf">l</span> <span class="s">&quot;test&quot;</span><span class="p">)]]))</span>
<span class="p">(</span><span class="nb">= </span><span class="mi">0</span> <span class="p">(</span><span class="nf">model-to-triples</span> <span class="nv">*ml*</span><span class="p">))</span>
</code></pre>
</div><h2 id="io">Input/Output</h2>
<p>Triples inside a model can be serialized to different formats using the<br />
<code>model-to-document</code> function.</p>
<p>Currently supported formats are:</p>
<ul>
	<li><span class="caps">XML</span>/<span class="caps">RDF</span></li>
	<li>N3</li>
	<li>Turtle</li>
</ul>
<p>The following example code:</p>
<div class="highlight"><pre><code class="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">*m*</span> <span class="p">(</span><span class="nf">with-rdf-ns</span> <span class="s">&quot;http://test.com/&quot;</span>
               <span class="p">(</span><span class="nf">defmodel</span> <span class="p">(</span><span class="nf">model-add-triples</span> <span class="p">[[</span><span class="nv">:a</span> <span class="nv">:b</span> <span class="p">(</span><span class="nf">d</span> <span class="mi">1</span><span class="p">)]]))))</span>
<span class="p">(</span><span class="nf">model-to-format</span> <span class="nv">*m*</span> <span class="nv">:xml</span><span class="p">)</span>
</code></pre>
</div><p>Will generate the following output:</p>
<div class="highlight"><pre><code class="xml"><span class="nt">&lt;rdf:RDF</span>
    <span class="na">xmlns:rdf=</span><span class="s">&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;</span>
    <span class="na">xmlns:j.0=</span><span class="s">&quot;http://test.com/&quot;</span> <span class="nt">&gt;</span>
  <span class="nt">&lt;rdf:Description</span> <span class="na">rdf:about=</span><span class="s">&quot;http://test.com/a&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;j.0:b</span> <span class="na">rdf:datatype=</span><span class="s">&quot;http://www.w3.org/2001/XMLSchema#int&quot;</span><span class="nt">&gt;</span>1<span class="nt">&lt;/j.0:b&gt;</span>
  <span class="nt">&lt;/rdf:Description&gt;</span>
<span class="nt">&lt;/rdf:RDF&gt;</span>
</code></pre>
</div><p>In the same way, other possible formats for graphs could be:</p>
<div class="highlight"><pre><code class="clojure"><span class="p">(</span><span class="nf">model-to-format</span> <span class="nv">*m*</span> <span class="nv">:n3</span><span class="p">)</span>
</code></pre>
</div><div class="highlight"><pre><code class="xml"><span class="nt">&lt;http:</span><span class="err">//test.com/a</span><span class="nt">&gt;</span>
      <span class="nt">&lt;http:</span><span class="err">//test.com/b</span><span class="nt">&gt;</span> &quot;1&quot;^^<span class="nt">&lt;http:</span><span class="err">//www.w3.org/2001/XMLSchema#int</span><span class="nt">&gt;</span> .
</code></pre>
</div><p>Creating models from input streams it is also possible using the <code>documet-to-model</code><br />
function.</p>
<div class="highlight"><pre><code class="clojure"><span class="p">(</span><span class="nf">document-to-model</span> <span class="p">(</span><span class="nf">java</span><span class="o">.</span><span class="nv">io</span><span class="o">.</span><span class="nv">FileInputStream</span><span class="o">.</span> <span class="s">&quot;/path/to/model.xml&quot;</span><span class="p">)</span> <span class="nv">:xml</span><span class="p">)</span>
</code></pre>
</div><h2 id="rdfa">Parsing RDFa documents</h2>
<p><a href="http://www.w3.org/TR/xhtml-rdfa-primer/">RDFa</a> is a different way of encoding any <span class="caps">RDF</span><br />
graph in a <span class="caps">XHTML</span> document. This format allows encoding data, data formatting information and meta data<br />
in  a single document.</p>
<p>The function <code>model-to-document</code> can be used to retrieve data from any web document<br />
providing the associated <span class="caps">URL</span>.</p>
<p>For instance the <span class="caps">RDF</span> graph annotated in the <span class="caps">HTML</span> document containing this <a
href="http://www.slideshare.net/Cloud/the-social-semantic-web-presentation">great presentation</a><br />
by John Breslin about the social semantic web, can be retrieved and parsed with the following code:</p>
<div class="highlight"><pre><code class="clojure"><span class="p">(</span><span class="nf">document-to-model</span> <span class="s">&quot;http://www.slideshare.net/Cloud/the-social-semantic-web-presentation&quot;</span> <span class="nv">:html</span><span class="p">)</span>
</code></pre>
</div><p>If we now try to output the graph in a different format:</p>
<div class="highlight"><pre><code class="clojure"><span class="p">(</span><span class="nf">model-to-format</span> <span class="nv">*m*</span> <span class="nv">:n3</span><span class="p">)</span>
</code></pre>
</div><p>The following document is generated:</p>
<div class="highlight"><pre><code class="xml">@prefix dc:      <span class="nt">&lt;http:</span><span class="err">//purl.org/dc/terms</span><span class="nt">/&gt;</span> .
@prefix hx:      <span class="nt">&lt;http:</span><span class="err">//purl.org/NET/hinclude</span><span class="nt">&gt;</span> .
@prefix media:   <span class="nt">&lt;http:</span><span class="err">//search.yahoo.com/searchmonkey/media</span><span class="nt">/&gt;</span> .
@prefix og:      <span class="nt">&lt;http:</span><span class="err">//opengraphprotocol.org/schema</span><span class="nt">/&gt;</span> .
@prefix fb:      <span class="nt">&lt;http:</span><span class="err">//developers.facebook.com/schema</span><span class="nt">/&gt;</span> .

<span class="nt">&lt;http:</span><span class="err">//www.slideshare.net/Cloud/the-social-semantic-web-presentation</span><span class="nt">&gt;</span>
      fb:app_id &quot;2490221586&quot;@en ;
      og:image &quot;http://cdn.slidesharecdn.com/200801027agalwayietcompsoc-1227870978372704-8-thumbnail-2?1227923401&quot;@en ;
      og:site_name &quot;SlideShare&quot;@en ;
      og:title &quot;The Social Semantic Web&quot;@en ;
      og:url  &quot;http://www.slideshare.net/Cloud/the-social-semantic-web-presentation&quot;@en ;
      dc:creator &quot;John Breslin&quot;@en ;
      dc:description &quot;IET Ireland Network and NUI Galway CompSoc Talk / DERI, NUI Galway / 27th November 2008&quot;@en ;
      media:height &quot;355&quot;@en ;
      media:presentation <span class="nt">&lt;http:</span><span class="err">//static.slidesharecdn.com/swf/ssplayer2.swf?</span><span class="na">doc=</span><span class="s">200801027agalwayietcompsoc-1227870978372704-8&amp;stripped_title=the-social-semantic-web-presentation</span><span class="nt">&gt;</span> ;
      media:thumbnail <span class="nt">&lt;http:</span><span class="err">//cdn.slidesharecdn.com/200801027agalwayietcompsoc-1227870978372704-8-thumbnail?1227923401</span><span class="nt">&gt;</span> ;
      media:title &quot;The Social Semantic Web&quot;@en ;
      media:width &quot;425&quot;@en ;
      <span class="nt">&lt;http:</span><span class="err">//www.w3.org/1999/xhtml/vocab#alternate</span><span class="nt">&gt;</span>
              <span class="nt">&lt;http:</span><span class="err">//www.slideshare.net/rss/latest</span><span class="nt">&gt;</span> ;
      <span class="nt">&lt;http:</span><span class="err">//www.w3.org/1999/xhtml/vocab#icon</span><span class="nt">&gt;</span>
              <span class="nt">&lt;http:</span><span class="err">//www.slideshare.net/favicon.ico</span><span class="nt">&gt;</span> ;
      <span class="nt">&lt;http:</span><span class="err">//www.w3.org/1999/xhtml/vocab#stylesheet</span><span class="nt">&gt;</span>
              <span class="nt">&lt;http:</span><span class="err">//public.slidesharecdn.com/v3/styles/combined.css?1273154379</span><span class="nt">&gt;</span> .
</code></pre>
</div><p>An <code>InputStream</code> instead of an <span class="caps">URI</span> string is also a valid argument. In the same way, for<br />
other formats different from RDFa, it is also possible to provide an <span class="caps">URI</span> pointing to the document to<br />
be parsed.</p>
<h2 id="processing">Triple sets processing</h2>
<p>Once the set of triples is built, or retrieved from a document, it consists just in a vector of triples.<br />
This means that operations like <code>map</code> or <code>filter</code> can be applied to the<br />
collection of triples as in any other Clojure collection. Each triple is also just a vector with<br />
three components: subject (first component), predicate (second component) and object (third<br />
component).</p>
<p>Nevertheless, each component is different from the representation provided to built the triple<br />
collection. <strong>clj-plaza</strong> provides a certain number of functions to manipulate these<br />
objects.</p>
<p>For example, the functions <code>subject</code>, <code>predicate</code> and <code>object</code>,<br />
and their shortcuts: <code>s</code>, <code>o</code> and <code>p</code>, can be used to extract the<br />
components of a triple.</p>
<p>If we would like to retrieve all the subjects of a set of triples we could write the<br />
following code:</p>
<div class="highlight"><pre><code class="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">*ts*</span> <span class="p">(</span><span class="nf">make-triples</span> <span class="p">[[</span><span class="nv">:a</span> <span class="nv">:b</span> <span class="p">(</span><span class="nf">l</span> <span class="s">&quot;test&quot;</span><span class="p">)]</span>
                            <span class="p">[</span><span class="nv">:c</span> <span class="p">[</span><span class="nv">:d</span> <span class="p">(</span><span class="nf">d</span> <span class="mi">1</span><span class="p">)</span>
                                 <span class="nv">:e</span> <span class="p">(</span><span class="nf">d</span> <span class="mf">3.6</span><span class="p">)]]]))</span>
<span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nv">s</span> <span class="nv">%1</span><span class="p">)</span> <span class="nv">*ts*</span><span class="p">)</span>
</code></pre>
</div><p>The output of this code is not <code>[:a :c :c]</code> but a list of resource objects.</p>
<p>We could use the function <code>resource-uri</code> to obtain the <span class="caps">URI</span> of the resources:</p>
<div class="highlight"><pre><code class="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">*ts*</span> <span class="p">(</span><span class="nf">make-triples</span> <span class="p">[[</span><span class="nv">:a</span> <span class="nv">:b</span> <span class="p">(</span><span class="nf">l</span> <span class="s">&quot;test&quot;</span><span class="p">)]</span>
                            <span class="p">[</span><span class="nv">:c</span> <span class="p">[</span><span class="nv">:d</span> <span class="p">(</span><span class="nf">d</span> <span class="mi">1</span><span class="p">)</span>
                                 <span class="nv">:e</span> <span class="p">(</span><span class="nf">d</span> <span class="mf">3.6</span><span class="p">)]]]))</span>
<span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nv">resource-uri</span> <span class="p">(</span><span class="nf">s</span> <span class="nv">%1</span><span class="p">))</span> <span class="nv">*ts*</span><span class="p">)</span>
</code></pre>
</div><p>The output of this code is:</p>
<div class="highlight"><pre><code class="clojure"><span class="p">(</span><span class="s">&quot;http://plaza.org/ontologies/a&quot;</span> <span class="s">&quot;http://plaza.org/ontologies/c&quot;</span> <span class="s">&quot;http://plaza.org/ontologies/c&quot;</span><span class="p">)</span>
</code></pre>
</div><p>In the same way we could use the function <code>resource-qname-local</code> to extract the local<br />
part of the qualified <span class="caps">URI</span> of the resource:</p>
<div class="highlight"><pre><code class="clojure">   <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nv">resource-qname-local</span> <span class="p">(</span><span class="nf">s</span> <span class="nv">%1</span><span class="p">))</span> <span class="nv">*ts*</span><span class="p">)</span>
</code></pre>
</div><p>The output of this version of the code is:</p>
<div class="highlight"><pre><code class="clojure"><span class="p">(</span><span class="s">&quot;a&quot;</span> <span class="s">&quot;c&quot;</span> <span class="s">&quot;c&quot;</span><span class="p">)</span>
</code></pre>
</div><p>Other examples of functions for retrieving data from the components of a triple set are<br />
<code>resource-qname-prefix</code>, <code>literal-value</code>, <code>literal-language</code>,<br />
<code>literal-lexical-form</code> or <code>is-resource</code>.</p>
<h2 id="predicates">Using predicates</h2>
<p>Other common problem is filtering and selecting parts of a triple set. <strong>clj-plaza</strong><br />
offers a small set of predicate functions that make easy querying a set of triples. All these<br />
functions are included in the namespace <code>plaza.rdf.predicates</code></p>
<p>For example, if we would like to retrieve all the triples in a triple set that have a literal as the<br />
object we could write the following code:</p>
<div class="highlight"><pre><code class="clojure"><span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;plaza</span><span class="o">.</span><span class="nv">rdf</span><span class="o">.</span><span class="nv">predicates</span><span class="p">)</span>
<span class="p">(</span><span class="nb">filter </span><span class="p">(</span><span class="nf">triple-check</span> <span class="p">(</span><span class="nf">object?</span> <span class="p">(</span><span class="nf">is-literal?</span><span class="p">)))</span> <span class="nv">*ts*</span><span class="p">)</span>
</code></pre>
</div><p>All the predicates are introduced by the function <code>triple-check</code> or the shortcut<br />
<code>tc</code>.</p>
<p>Queries can be combined using predicates <code>and?</code> and <code>or?</code> becoming quite<br />
expressive:</p>
<div class="highlight"><pre><code class="clojure"><span class="p">(</span><span class="nb">filter </span><span class="p">(</span><span class="nf">triple-check</span>
                  <span class="p">(</span><span class="nf">and?</span>  <span class="p">(</span><span class="nf">subject?</span> <span class="p">(</span><span class="nf">qname-local?</span> <span class="s">&quot;a&quot;</span><span class="p">))</span>
                          <span class="p">(</span><span class="nf">object?</span> <span class="p">(</span><span class="nf">and?</span>  <span class="p">(</span><span class="nf">is-literal?</span><span class="p">)</span>
                                            <span class="p">(</span><span class="nf">regex?</span> <span class="o">#</span><span class="s">&quot;test[a-z]*&quot;</span><span class="p">)))))</span>
          <span class="nv">*ts*</span><span class="p">)</span>
 
</code></pre>
</div><p>Two special predicates are <code>fn-apply?</code> and <code>fn-triple-apply?</code> that receive a<br />
lambda function as an argument returning a boolean value and pass as the only argument the current<br />
value or triple being filtered. These predicates can be used to make custom checks on the triple<br />
set.</p>
<p>For example we could write a query for retrieving all the triples with an object containing a<br />
literal of type integer and value less than 5:</p>
<div class="highlight"><pre><code class="clojure"><span class="p">(</span><span class="nb">filter </span><span class="p">(</span><span class="nf">triple-check</span> <span class="p">(</span><span class="nf">object-and?</span> <span class="p">(</span><span class="nf">datatype?</span> <span class="nv">:int</span><span class="p">)</span>
                                       <span class="p">(</span><span class="nf">fn-apply?</span> <span class="o">#</span><span class="p">(</span><span class="nv">&lt;</span> <span class="nv">%1</span> <span class="mi">5</span><span class="p">)))</span>
          <span class="nv">*ts*</span><span class="p">)</span>
</code></pre>
</div><h2 id="patterns_triples">Patterns, queries, triple sets and models</h2>
<p><strong>clj-plaza</strong> predicates are only a lightweight way of querying a <span class="caps">RDF</span> graph encoded as<br />
a set of triples. The standard way of querying <span class="caps">RDF</span> graphs is the <a
href="http://www.w3.org/TR/rdf-sparql-query/"><span class="caps">SPARQL</span></a> query language.</p>
<p>The support for <span class="caps">SPARQL</span> included in the library can be found in the <code>plaza.rdf.sparql</code><br />
namespace.</p>
<p>The first concept introduced in this namespace is that of a pattern. A pattern can be thought as a<br />
<span class="caps">RDF</span> graph where some nodes have been substituted by variables. A pattern could be later transformed<br />
into a query object, in the same way that a <strong>clj-plaza</strong> triple set can be transformed<br />
into a model object.</p>
<p>Patterns are just plain Clojure vectors where each element is also a vector with subject, predicate<br />
and object.</p>
<p>Furhtermore, a triple set can be transformed into a pattern <em>abstracting</em> some values and a pattern<br />
and it can be transformed back into a triple set <em>binding</em> all the variables in the  pattern.</p>
<p>A pattern can also be <em>applied</em> to a triple set or model to obtain a collection of triple sets where<br />
the pattern variables have been bound to values from the triple set.</p>
<div id="img_wrapper">
<p><img src="/clj-plaza/images/rels.png"></img></p>
</div>
<h2 id="pattern_building">Building patterns</h2>
<p>A pattern can be built using the <code>make-pattern</code> function in the<br />
<code>plaza.rdf.sparql</code> namespace:</p>
<div class="highlight"><pre><code class="clojure"><span class="p">(</span><span class="nf">make-pattern</span> <span class="p">[[</span><span class="nv">:?s</span> <span class="nv">rdf:type</span> <span class="nv">:Post</span><span class="p">]])</span>
</code></pre>
</div><p>The keyword <code>:?s</code> introduces a variable in the query.  Any symbol starting with a<br />
question mark is interpreted as a pattern variable. Variables ?a, ?b, ?c&#8230; etc are so common that<br />
they are defined with especial symbols by the library:</p>
<div class="highlight"><pre><code class="clojure"><span class="p">(</span><span class="nf">make-pattern</span> <span class="p">[[</span><span class="nv">?s</span> <span class="nv">rdf:type</span> <span class="nv">:Post</span><span class="p">]])</span>
</code></pre>
</div><p>The variables in a pattern can be retrieved using the function<br />
<code>pattern-collect-vars</code>. Variables inside a pattern can be transformed into values using<br />
the <code>pattern-bind</code> function, providing a map with variable substitutions:</p>
<div class="highlight"><pre><code class="clojure"><span class="p">(</span><span class="nf">pattern-bind</span> <span class="p">[[</span><span class="nv">?a</span> <span class="nv">rdf:type</span> <span class="nv">:Post</span><span class="p">]]</span> <span class="p">{</span><span class="nv">?a</span> <span class="s">&quot;post-a&quot;</span><span class="p">})</span>
</code></pre>
</div><p>A pattern can be transformed into a collection of triple sets, where the variables of the pattern<br />
have been bound to the values of triples in the original collection matching the pattern triples:</p>
<div class="highlight"><pre><code class="clojure"><span class="p">(</span><span class="nf">pattern-apply</span> <span class="p">[[</span><span class="nv">:ba</span> <span class="nv">rdf:type</span> <span class="nv">:Post</span><span class="p">]</span>
                  <span class="p">[</span><span class="nv">:bb</span> <span class="nv">rdf:type</span> <span class="nv">:Post</span><span class="p">]]</span>
                 <span class="p">[[</span><span class="nv">?a</span> <span class="nv">rdf:type</span> <span class="nv">:Post</span><span class="p">]])</span>
</code></pre>
</div><p>will yield a list with two triple sets, in the first the variable ?a will be replaced by the<br />
resource with local qname &#8220;ba&#8221; and in the second, the variable will be replaced by the resource with<br />
local qname &#8220;bb&#8221;.</p>
<p>In the same way, a triple set can be transformed into a pattern <em>abstracting</em> some of the values in<br />
the triple set using the function <code>triples-abstraction</code>.</p>
<p><code>triples-abstraction</code> receives two arguments, a predicate, selecting the triples in the<br />
triple set where values are going to be replaced by variables and a map with the components of the<br />
previously matched triple to be replaced:</p>
<div class="highlight"><pre><code class="clojure"><span class="p">(</span><span class="nf">triples-abstraction</span> <span class="nv">*ts*</span> <span class="p">(</span><span class="nf">subject?</span> <span class="p">(</span><span class="nf">uri?</span> <span class="s">&quot;http://plaza.org/ontologies/a&quot;</span><span class="p">))</span> <span class="p">{</span><span class="nv">:subject</span> <span class="nv">:?x</span><span class="p">})</span>
</code></pre>
</div><h2 id="defquery">Defining queries</h2>
<p>A pattern can be transformed into many <span class="caps">SPARQL</span> queries using the <code>defquery</code> macro.</p>
<p>This macro accepts a set of query building functions defining all the components of the query:</p>
<ul>
	<li>kind of query</li>
	<li>variables to be returned</li>
	<li>pattern</li>
	<li>offset, limit, reduce, distinct clauses</li>
</ul>
<p>The following sample of code defines a complex <span class="caps">SPARQL</span> query:</p>
<div class="highlight"><pre><code class="clojure"><span class="p">(</span><span class="nf">defquery</span>
      <span class="p">(</span><span class="nf">query-set-vars</span> <span class="p">[</span><span class="nv">?s</span><span class="p">])</span>
      <span class="p">(</span><span class="nf">query-set-pattern</span> <span class="p">(</span><span class="nf">make-pattern</span> <span class="p">[[</span><span class="nv">?s</span> <span class="nv">?p</span> <span class="nv">?o</span><span class="p">]]))</span>
      <span class="p">(</span><span class="nf">query-set-type</span> <span class="nv">:select</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">query-set-limit</span> <span class="mi">2</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">query-set-distinct</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">query-set-offset</span> <span class="mi">5</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">query-set-reduced</span><span class="p">))</span>
</code></pre>
</div><p>We can later use the function <code>query-to-string</code> to obtain the string representation of<br />
the query:</p>
<div class="highlight"><pre><code class="sql"><span class="ss">&quot;SELECT DISTINCT REDUCED ?s WHERE {?s ?p ?o .} OFFSET 5 LIMIT 2&quot;</span>
</code></pre>
</div><p>Some triples in a pattern can be marked as <a
href="http://www.w3.org/TR/rdf-sparql-query/#optionals">optional</a>. These triples will only be<br />
returned as a result by a <span class="caps">SPARQL</span> query or in a triple application if the variables can be bound.</p>
<p>Optional parts of a pattern can be defined using the <code>optional</code> function or the<br />
<code>opt</code> shortcut.</p>
<div class="highlight"><pre><code class="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">*pattern*</span> <span class="p">(</span><span class="nf">make-pattern</span> <span class="p">[[</span><span class="nv">?x</span> <span class="nv">rdf:type</span> <span class="nv">:http://test</span><span class="o">.</span><span class="nv">com/Test</span><span class="p">]</span>
                                <span class="p">(</span><span class="nf">optional</span> <span class="p">[</span><span class="nv">?y</span> <span class="nv">?z</span> <span class="p">(</span><span class="nf">d</span> <span class="mi">2</span><span class="p">)])]))</span>

<span class="p">(</span><span class="nf">defquery</span>
              <span class="p">(</span><span class="nf">query-set-vars</span> <span class="p">[</span><span class="nv">?y</span><span class="p">])</span>
              <span class="p">(</span><span class="nf">query-set-type</span> <span class="nv">:select</span><span class="p">)</span>
              <span class="p">(</span><span class="nf">query-set-pattern</span> <span class="nv">*pattern*</span><span class="p">))</span>
</code></pre>
</div><p>If we print this query we will obtain the following string:</p>
<div class="highlight"><pre><code class="sql"><span class="ss">&quot;SELECT ?y</span>
<span class="ss">WHERE { ?x rdf:type &lt;http://test.com/Test&gt; .</span>
<span class="ss">       OPTIONAL { ?y ?z &#39;2&#39;^^&lt;http://www.w3.org/2001/XMLSchema#int&gt; .} }&quot;</span>
</code></pre>
</div><h2 id="filters">Adding filters</h2>
<p>The <span class="caps">SPARQL</span> standard defines a set of <a href="http://www.w3.org/TR/rdf-sparql-query/#tests">filter<br />
functions</a> that can be added to a query to filter the solutions of a query.</p>
<p>The <code>make-filter</code> function can build this filters that can be later applied to a query<br />
using the <code>query-set-filters</code> function, accepting a list of filters:</p>
<div class="highlight"><pre><code class="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">*pattern*</span> <span class="p">(</span><span class="nf">make-pattern</span> <span class="p">[[</span><span class="nv">?x</span> <span class="nv">rdf:type</span> <span class="nv">:http://test</span><span class="o">.</span><span class="nv">com/Test</span><span class="p">]</span>
                                <span class="p">(</span><span class="nf">optional</span> <span class="p">[</span><span class="nv">?y</span> <span class="nv">?z</span> <span class="p">(</span><span class="nf">d</span> <span class="mi">2</span><span class="p">)])]))</span>

<span class="p">(</span><span class="nf">defquery</span>
              <span class="p">(</span><span class="nf">query-set-vars</span> <span class="p">[</span><span class="nv">?y</span><span class="p">])</span>
              <span class="p">(</span><span class="nf">query-set-type</span> <span class="nv">:select</span><span class="p">)</span>
              <span class="p">(</span><span class="nf">query-set-pattern</span> <span class="nv">*pattern*</span><span class="p">)</span>
              <span class="p">(</span><span class="nf">query-set-filters</span> <span class="p">[(</span><span class="nf">make-filter</span> <span class="nv">:&gt;</span> <span class="nv">:?y</span> <span class="p">(</span><span class="nf">d</span> <span class="mi">2</span><span class="p">))]))</span>
</code></pre>
</div><p>make filter accepts a symbol identifying the filter function and some additional arguments that are<br />
the arguments to the filter function.</p>
<p>Some example of filter functions available are: <code>+</code>, <code>-</code>, <code>*</code>,<br />
<code>div</code>, <code>str</code>, <code>lang</code>, <code>bound</code>, or<br />
<code>isLiteral</code>.</p>
<h2 id="making_queries">Using queries</h2>
<p>Queries can be used to match variables in models. The function used is<br />
<code>model-query</code>. This function receives a model and query and returns a list of maps with<br />
the variables in the query matching the query:</p>
<div class="highlight"><pre><code class="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">*q*</span> <span class="p">(</span><span class="nf">defquery</span>
                <span class="p">(</span><span class="nf">query-set-type</span> <span class="nv">:select</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">query-set-vars</span> <span class="p">[</span><span class="nv">:?x</span><span class="p">])</span>
                <span class="p">(</span><span class="nf">query-set-pattern</span>
                 <span class="p">(</span><span class="nf">make-pattern</span> <span class="p">[[</span><span class="nv">:?x</span> <span class="s">&quot;a&quot;</span> <span class="p">(</span><span class="nf">d</span> <span class="mi">2</span><span class="p">)]]))))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">*ts*</span> <span class="p">(</span><span class="nf">make-triples</span> <span class="p">[[</span><span class="nv">:m</span> <span class="nv">:a</span> <span class="p">(</span><span class="nf">d</span> <span class="mi">2</span><span class="p">)]</span>
                         <span class="p">[</span><span class="nv">:n</span> <span class="nv">:b</span> <span class="p">(</span><span class="nf">d</span> <span class="mi">2</span><span class="p">)]</span>
                         <span class="p">[</span><span class="nv">:o</span> <span class="nv">:a</span> <span class="p">(</span><span class="nf">d</span> <span class="mi">2</span><span class="p">)]</span>
                         <span class="p">[</span><span class="nv">:p</span> <span class="nv">:a</span> <span class="p">(</span><span class="nf">d</span> <span class="mi">3</span><span class="p">)]]))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">*m*</span> <span class="p">(</span><span class="nf">defmodel</span>
           <span class="p">(</span><span class="nf">model-add-triples</span> <span class="nv">triples</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">model-query</span> <span class="nv">model</span> <span class="nv">query</span><span class="p">)</span>
</code></pre>
</div><p>The previous code sample will return the following list of binding maps as the result:</p>
<div class="highlight"><pre><code class="clojure"><span class="p">({</span><span class="nv">:?x</span> <span class="o">#</span><span class="nv">&lt;ResourceImpl</span> <span class="nv">http://plaza</span><span class="o">.</span><span class="nv">org/ontologies/o&gt;</span><span class="p">}</span>
 <span class="p">{</span><span class="nv">:?x</span> <span class="o">#</span><span class="nv">&lt;ResourceImpl</span> <span class="nv">http://plaza</span><span class="o">.</span><span class="nv">org/ontologies/m&gt;</span><span class="p">})</span>
</code></pre>
</div><p>Alternatively, the function <code>model-query-triples</code> can be used to retrieve the triple sets<br />
where the binding maps have been applied.</p>
</div>


      <p id="footer">
      </p>

    </div>
  </body>
</html>
